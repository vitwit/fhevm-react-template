/**
 * DON'T MODIFY OR DELETE THIS SCRIPT (unless you know what you're doing)
 *
 * This script generates the file containing the contracts ABI definitions.
 * These definitions are used to derive the types needed in the custom fhevm hooks, for example.
 * This script should run as the last deploy script.
 */

import * as fs from "fs";
import * as prettier from "prettier";

const generatedContractComment = `
/**
 * This file is autogenerated by helper.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

const DEPLOYMENTS_DIR = "./packages/hardhat/deployments";
const ARTIFACTS_DIR = "./packages/hardhat/artifacts";

// Multiple output folders
const TARGET_DIRS = [
  "./packages/fhevm-next-demo/src/contracts/",
  "./packages/fhevm-vue-demo/src/contracts/",
  "./packages/fhevm-node-demo/src/contracts/",
];

function getDirectories(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
}

function getContractNames(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isFile() && dirent.name.endsWith(".json"))
    .map(dirent => dirent.name.split(".")[0]);
}

function getActualSourcesForContract(sources: Record<string, any>, contractName: string) {
  for (const sourcePath of Object.keys(sources)) {
    const sourceName = sourcePath.split("/").pop()?.split(".sol")[0];
    if (sourceName === contractName) {
      const contractContent = sources[sourcePath].content as string;
      const regex = /contract\s+(\w+)\s+is\s+([^{}]+)\{/;
      const match = contractContent.match(regex);

      if (match) {
        const inheritancePart = match[2];
        const inheritedContracts = inheritancePart.split(",").map(contract => `${contract.trim()}.sol`);
        return inheritedContracts;
      }
      return [];
    }
  }
  return [];
}

function getInheritedFunctions(sources: Record<string, any>, contractName: string) {
  const actualSources = getActualSourcesForContract(sources, contractName);
  const inheritedFunctions = {} as Record<string, any>;

  for (const sourceContractName of actualSources) {
    const sourcePath = Object.keys(sources).find(key => key.includes(`/${sourceContractName}`));
    if (sourcePath) {
      const sourceName = sourcePath?.split("/").pop()?.split(".sol")[0];
      const artifactPath = `${ARTIFACTS_DIR}/${sourcePath}/${sourceName}.json`;
      if (fs.existsSync(artifactPath)) {
        const { abi } = JSON.parse(fs.readFileSync(artifactPath).toString());
        for (const functionAbi of abi) {
          if (functionAbi.type === "function") {
            inheritedFunctions[functionAbi.name] = sourcePath;
          }
        }
      }
    }
  }

  return inheritedFunctions;
}

function getContractDataFromDeployments() {
  if (!fs.existsSync(DEPLOYMENTS_DIR)) {
    throw Error("At least one other deployment script should exist to generate an actual contract.");
  }

  const output = {} as Record<string, any>;
  const chainDirectories = getDirectories(DEPLOYMENTS_DIR);

  for (const chainName of chainDirectories) {
    let chainId;
    try {
      chainId = fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/.chainId`).toString();
    } catch {
      console.log(`No chainId file found for ${chainName}`);
      continue;
    }

    const contracts = {} as Record<string, any>;
    for (const contractName of getContractNames(`${DEPLOYMENTS_DIR}/${chainName}`)) {
      const { abi, address, metadata, receipt } = JSON.parse(
        fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/${contractName}.json`).toString(),
      );

      const inheritedFunctions = metadata ? getInheritedFunctions(JSON.parse(metadata).sources, contractName) : {};
      contracts[contractName] = { address, abi, inheritedFunctions, deployedOnBlock: receipt?.blockNumber };
    }

    output[chainId] = contracts;
  }

  return output;
}

const generateTsAbis = async function () {
  const allContractsData = getContractDataFromDeployments();

  const fileContent = Object.entries(allContractsData).reduce((content, [chainId, chainConfig]) => {
    return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(chainConfig, null, 2)},`;
  }, "");

  const formatted = await prettier.format(
    `${generatedContractComment}
import { GenericContractsDeclaration } from "../../utils/helper/contract";

const deployedContracts = {${fileContent}} as const;

export default deployedContracts satisfies GenericContractsDeclaration;
`,
    { parser: "typescript" },
  );

  for (const targetDir of TARGET_DIRS) {
    if (!fs.existsSync(targetDir)) {
      fs.mkdirSync(targetDir, { recursive: true });
    }
    fs.writeFileSync(`${targetDir}/deployedContracts.ts`, formatted);
    console.log(`üìù Updated TypeScript contract definition file at ${targetDir}/deployedContracts.ts`);
  }
};

export default generateTsAbis;

// Execute when run via ts-node
void generateTsAbis();
